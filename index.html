<!doctype html>
<html lang="en">
<head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"></head>
<title>Clash-Lite Singlefile</title>
<style>
:root{{--bg:#04040a;--gold:#ffd86b;--deep:#ffb85a;--red:#ff3f2f;--muted:#e6e6e8}}
*{{box-sizing:border-box;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}}
body{{margin:0;background:linear-gradient(180deg,#071018,#04040a);color:var(--muted)}}
.app{{display:flex;min-height:100vh;gap:20px;padding:28px}}
.panel{{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:12px;border-radius:12px;flex:1;min-width:320px}}
h2{{color:var(--gold);margin:6px 0 12px}}
.deckGrid{{display:flex;gap:8px;flex-wrap:wrap}}
.deckCard{{width:96px;height:120px;background:rgba(11,11,15,0.9);border-radius:10px;padding:8px;display:flex;flex-direction:column;align-items:center;justify-content:space-between;cursor:grab;border:1px solid rgba(255,255,255,0.03)}}
.deckCard.dragging{{opacity:0.5;transform:scale(0.98)}}
.deckControls{{display:flex;gap:8px;margin-top:10px}}
.canvasWrap{{flex:2;display:flex;flex-direction:column;align-items:center;gap:12px}}
canvas{{border-radius:12px;background:radial-gradient(circle at 50% 40%, #2b0b06 0%, #07070a 55%);box-shadow:0 40px 100px rgba(0,0,0,0.7)}}
.handArea{{display:flex;gap:8px;align-items:center;overflow:auto;padding:6px}}
.handCard{{width:90px;height:120px;background:linear-gradient(180deg,#0b0b0f,#0a0a0d);border-radius:8px;display:flex;flex-direction:column;align-items:center;justify-content:space-between;padding:8px;cursor:pointer;border:1px solid rgba(255,255,255,0.02)}}
.elixir{{display:flex;align-items:center;gap:12px}}
.elixirMeter{{width:320px;height:30px;border-radius:18px;background:rgba(255,255,255,0.03);position:relative;overflow:hidden;border:1px solid rgba(255,255,255,0.03)}}
.elixirFill{{position:absolute;left:0;top:0;height:100%;width:0;background:linear-gradient(90deg,var(--gold),var(--deep));transition:width .12s linear}}
.small{{font-size:12px;color:#bbb}}
.headerBtns{{display:flex;gap:8px;justify-content:flex-end}}
.btn{{padding:8px 12px;border-radius:8px;border:none;cursor:pointer;font-weight:700}}
.btn.primary{{background:linear-gradient(90deg,var(--gold),var(--deep));color:#081017}}
.note{{font-size:13px;color:#cfcfcf;margin-top:8px}}
</style>
<body>
<div style="display:flex;align-items:center;justify-content:space-between;padding:14px 28px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent)">
  <div><strong style="color:var(--gold)">Clash-Lite — Singlefile</strong></div>
  <div class="headerBtns"><button id="btnSaveDeck" class="btn">Save Deck</button><button id="btnReset" class="btn">Reset</button></div>
</div>
<div class="app">
  <div class="panel" style="max-width:420px">
    <h2>Deck</h2>
    <div id="deckArea" class="deckGrid"></div>
    <div class="deckControls"><button id="btnAddRandom" class="btn">Add Random</button><button id="btnClearDeck" class="btn">Clear Deck</button></div>
    <div class="note">Drag cards from the deck area directly onto the arena to deploy them. Touch and click supported.</div>
  </div>

  <div class="canvasWrap">
    <canvas id="arena" width="1100" height="620"></canvas>
    <div style="display:flex;align-items:center;justify-content:space-between;width:1100px">
      <div class="handArea" id="handArea"></div>
      <div class="elixir"><div class="elixirMeter"><div id="elixirFill" class="elixirFill"></div></div><div class="small" id="elixirText">0/10</div></div>
    </div>
  </div>

  <div class="panel" style="max-width:320px">
    <h2>Card Pool</h2>
    <div id="cardPool" class="deckGrid"></div>
    <div style="height:8px"></div>
    <div class="note">SVG icons are used (crisp). Click to add to deck or drag directly to arena.</div>
  </div>
</div>

<script>
const CARD_DATA = {"cards": [{"id": "gladius", "name": "Gladius", "cost": 3, "hp": 90, "atk": 16, "speed": 62, "size": 12, "type": "melee", "desc": "Skilled gladiator, balanced."}, {"id": "pilum", "name": "Pilum", "cost": 3, "hp": 48, "atk": 12, "speed": 78, "size": 10, "type": "ranged", "desc": "Javelin thrower with reach."}, {"id": "centurion", "name": "Centurion", "cost": 5, "hp": 170, "atk": 28, "speed": 36, "size": 18, "type": "melee", "desc": "Leader unit, strong armor."}, {"id": "velox", "name": "Velox", "cost": 2, "hp": 34, "atk": 8, "speed": 150, "size": 9, "type": "fast", "desc": "Fast skirmisher."}, {"id": "pyre", "name": "Pyre", "cost": 4, "hp": 1, "atk": 70, "radius": 70, "type": "spell", "desc": "Explosive area damage."}, {"id": "medic", "name": "Medic", "cost": 5, "hp": 70, "atk": 0, "heal": 10, "radius": 54, "speed": 40, "size": 10, "type": "support", "desc": "Heals nearby allies."}, {"id": "sapper", "name": "Sapper", "cost": 3, "hp": 60, "atk": 12, "speed": 88, "size": 10, "type": "special", "desc": "Burrows to spot and attack."}, {"id": "colossus", "name": "Colossus", "cost": 8, "hp": 420, "atk": 48, "speed": 20, "size": 26, "type": "melee", "desc": "Massive push unit."}, {"id": "lion", "name": "Lion", "cost": 4, "hp": 120, "atk": 22, "speed": 52, "size": 14, "type": "melee", "desc": "Ferocious beast with charge."}, {"id": "ballista", "name": "Ballista", "cost": 6, "hp": 160, "atk": 36, "speed": 16, "size": 20, "type": "ranged", "desc": "Long-range siege unit."}]}.cards;
let deck = [];
let playerHand = [], playerDeck = [];
let selectedDrag = null;
const arena = document.getElementById('arena'); const ctx = arena.getContext('2d');
const deckArea = document.getElementById('deckArea'); const cardPool = document.getElementById('cardPool');
const handArea = document.getElementById('handArea'); const elixirFill = document.getElementById('elixirFill'); const elixirText = document.getElementById('elixirText');
let playerElixir = 4, MAX_ELIXIR=10, ELIXIR_RATE=0.45;
let entities = [], towers=[]; let lastTime = performance.now(); let gameRunning=false;
function buildPool(){ cardPool.innerHTML=''; CARD_DATA.forEach(c=>{ const el=document.createElement('div'); el.className='deckCard'; el.draggable=true; el.innerHTML=`<img src="icons/${c.id}.svg" style="width:64px;height:64px"><div style="font-size:13px">${c.name}</div><div style="font-weight:900">${c.cost}</div>`; el.addEventListener('click', ()=>{ addToDeck(c.id); }); el.addEventListener('dragstart', (e)=>{ selectedDrag={id:c.id,from:'pool'}; }); cardPool.appendChild(el); }); }
function renderDeck(){ deckArea.innerHTML=''; for(let i=0;i<8;i++){ const el=document.createElement('div'); el.className='deckCard'; el.dataset.slot=i; if(deck[i]){ const c = CARD_DATA.find(x=>x.id===deck[i]); el.innerHTML=`<img src="icons/${c.id}.svg" style="width:64px;height:64px"><div style="font-size:12px">${c.name}</div><div style="font-weight:900">${c.cost}</div>`; el.addEventListener('dragstart', (e)=>{ selectedDrag={id:c.id,from:'deck',slot:i}; e.dataTransfer.setData('text/plain', c.id); el.classList.add('dragging'); }); el.draggable=true; el.addEventListener('dragend', ()=> el.classList.remove('dragging')); el.addEventListener('click', ()=>{ deck.splice(i,1); renderDeck(); }); } else { el.innerHTML='+'; el.addEventListener('dragover', (ev)=> ev.preventDefault()); el.addEventListener('drop', (ev)=>{ ev.preventDefault(); const id = ev.dataTransfer.getData('text/plain') || (selectedDrag && selectedDrag.id); if(id){ deck[i]=id; renderDeck(); } }); } deckArea.appendChild(el); } }
function addToDeck(id){ if(deck.length>=8){ alert('Deck full'); return; } deck.push(id); renderDeck(); }
document.getElementById('btnAddRandom').addEventListener('click', ()=>{ const ids=CARD_DATA.map(c=>c.id); while(deck.length<8) deck.push(ids[Math.floor(Math.random()*ids.length)]); renderDeck(); });
document.getElementById('btnClearDeck').addEventListener('click', ()=>{ deck=[]; renderDeck(); });
document.getElementById('btnSaveDeck').addEventListener('click', ()=>{ localStorage.setItem('clashlite_deck', JSON.stringify(deck)); alert('Deck saved'); });
document.getElementById('btnReset').addEventListener('click', ()=>{ localStorage.removeItem('clashlite_deck'); location.reload(); });

function loadSavedDeck(){ const d = localStorage.getItem('clashlite_deck'); if(d){ try{ deck=JSON.parse(d);}catch(e){ deck=[]; } } else { deck = CARD_DATA.slice(0,8).map(c=>c.id); } renderDeck(); }
buildPool(); loadSavedDeck();

function startMatch(){ playerDeck = deck.slice(); playerHand=[]; for(let i=0;i<4;i++) drawCard(); setupTowers(); playerElixir=4; gameRunning=true; lastTime=performance.now(); requestAnimationFrame(loop); }
function drawCard(){ if(playerDeck.length) playerHand.push(playerDeck.shift()); renderHand(); }
function renderHand(){ handArea.innerHTML=''; playerHand.forEach((id,i)=>{ const c = CARD_DATA.find(x=>x.id===id); const el=document.createElement('div'); el.className='handCard'; el.innerHTML=`<img src="icons/${id}.svg" style="width:56px;height:56px"><div style="font-size:12px">${c.name}</div><div style="font-weight:900">${c.cost}</div>`; el.addEventListener('click', ()=> { selectedDrag={id:id,from:'hand',index:i}; }); el.addEventListener('dragstart', (e)=>{ selectedDrag={id:id,from:'hand',index:i}; }); handArea.appendChild(el); }); elixirText.innerText = Math.floor(playerElixir) + '/' + MAX_ELIXIR; elixirFill.style.width = Math.min(100, (playerElixir/MAX_ELIXIR)*100) + '%'; }

function setupTowers(){ towers = [ {x:120,y:150,team:0,hp:220,maxHp:220,range:160,fireCd:0}, {x:120,y:310,team:0,hp:480,maxHp:480,range:220,fireCd:0,main:true}, {x:120,y:470,team:0,hp:220,maxHp:220,range:160,fireCd:0}, {x:980,y:150,team:1,hp:220,maxHp:220,range:160,fireCd:0}, {x:980,y:310,team:1,hp:480,maxHp:480,range:220,fireCd:0,main:true}, {x:980,y:470,team:1,hp:220,maxHp:220,range:160,fireCd:0} ]; entities=[]; }

arena.addEventListener('dragover', e=> e.preventDefault());
arena.addEventListener('drop', e=>{ e.preventDefault(); const id = e.dataTransfer.getData('text/plain') || (selectedDrag && selectedDrag.id); if(!id) return; const rect = arena.getBoundingClientRect(); const x = e.clientX - rect.left, y = e.clientY - rect.top; deployFromDrag(id,x,y); });
arena.addEventListener('click', (e)=>{ if(selectedDrag && selectedDrag.from && selectedDrag.id){ const rect = arena.getBoundingClientRect(); const x = e.clientX - rect.left, y = e.clientY - rect.top; deployFromDrag(selectedDrag.id,x,y); selectedDrag=null; } });
arena.addEventListener('touchstart', (e)=>{ if(selectedDrag && selectedDrag.id){ const touch = e.touches[0]; const rect = arena.getBoundingClientRect(); const x = touch.clientX - rect.left, y = touch.clientY - rect.top; deployFromDrag(selectedDrag.id,x,y); selectedDrag=null; } });

function deployFromDrag(id,x,y){ if(x > arena.width/2 - 40){ alert('Place on your side (left half)'); return; } const spawnX = Math.max(100, Math.min(x, arena.width/2 - 80)); const spawnY = Math.max(80, Math.min(y, arena.height-80)); const c = CARD_DATA.find(xx=>xx.id===id); if(!c) return; if(playerElixir < c.cost){ alert('Not enough elixir'); return; } playerElixir -= c.cost; renderHand(); entities.push({kind:'unit',id:id,team:0,x:spawnX,y:spawnY,hp:c.hp,atk:c.atk,speed:c.speed,size:c.size,cd:0,heal:c.heal||0}); if(selectedDrag && selectedDrag.from==='hand'){ playerDeck.push(playerHand.splice(selectedDrag.index,1)[0]); drawCard(); } }

let aiTimer=0; let enemyDeck = CARD_DATA.map(c=>c.id).slice(), enemyHand=[];
function aiBehavior(dt){ aiTimer+=dt; if(aiTimer>1.0){ aiTimer=0; if(enemyDeck.length<1) enemyDeck = CARD_DATA.map(c=>c.id).slice(); if(enemyHand.length<3) enemyHand.push(enemyDeck.shift()); for(let i=0;i<enemyHand.length;i++){ const id=enemyHand[i]; const c=CARD_DATA.find(x=>x.id===id); if(c && c.cost <= Math.floor(playerElixir*1.1)){ const tx = arena.width - 220 + (Math.random()-0.5)*40; const ty = (Math.random()<0.5? 150:470) + (Math.random()-0.5)*24; entities.push({kind:'unit',id:id,team:1,x:tx,y:ty,hp:c.hp,atk:c.atk,speed:c.speed,size:c.size,cd:0}); enemyHand.splice(i,1); break; } } } }

function updateEntities(dt){ towers.forEach(t=>{ t.fireCd-=dt; if(t.fireCd<0) t.fireCd=0; if(t.hp>0){ const enemies = entities.filter(u=>u.kind==='unit' && u.team!==t.team); if(enemies.length){ enemies.sort((a,b)=>Math.hypot(a.x-t.x,a.y-t.y)-Math.hypot(b.x-t.x,b.y-t.y)); const target=enemies[0]; const d=Math.hypot(target.x-t.x,target.y-t.y); if(d<=t.range && t.fireCd===0){ t.fireCd=1.1; target.hp-=36; } } } }); for(let i=entities.length-1;i>=0;i--){ const e=entities[i]; if(e.kind==='unit'){ let target = entities.filter(u=> u.kind==='unit' && u.team!==e.team).sort((a,b)=> Math.hypot(a.x-e.x,a.y-e.y)-Math.hypot(b.x-e.x,b.y-e.y))[0]; if(!target){ target = towers.filter(t=> t.team!==e.team).sort((a,b)=> Math.abs(a.y-e.y)-Math.abs(b.y-e.y))[0]; if(target) target._isTower=true; } if(target){ const dx=target.x-e.x, dy=target.y-e.y; const dist=Math.hypot(dx,dy); if(dist>(e.size+(target.size||20))+6){ const nx=dx/dist, ny=dy/dist; e.x+=nx*e.speed*dt; e.y+=ny*e.speed*dt; } else { e.cd-=dt; if(e.cd<=0){ e.cd=0.85-Math.min(0.45,e.speed/300); if(target._isTower){ target.hp-=e.atk; } else { target.hp-=e.atk; } } } } else { e.x += (e.team===0?1:-1)*e.speed*dt; } if(e.hp<=0 || e.x<-200 || e.x>arena.width+200) entities.splice(i,1); } } towers = towers.filter(t=>t.hp>0); }

function draw(){ ctx.clearRect(0,0,arena.width,arena.height); for(let i=0;i<5;i++){ ctx.beginPath(); ctx.strokeStyle = i%2? '#3a0b06':'#1e0704'; ctx.lineWidth=10- i; ctx.arc(arena.width/2, arena.height/2, 220 - i*30, 0, Math.PI*2); ctx.stroke(); } towers.forEach(t=>{ ctx.fillStyle = t.team===0? '#072a2b':'#3a0707'; ctx.fillRect(t.x-50,t.y-50,100,100); ctx.fillStyle = t.main? '#ffd86b' : '#ffdfb0'; ctx.beginPath(); ctx.arc(t.x,t.y-28,16,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#111'; ctx.fillRect(t.x-44,t.y+40,88,8); ctx.fillStyle='#3cf55a'; ctx.fillRect(t.x-44,t.y+40,Math.max(0,88*(t.hp/t.maxHp)),8); }); entities.forEach(e=>{ if(e.kind==='unit'){ ctx.beginPath(); ctx.ellipse(e.x,e.y+e.size+6,e.size*1.5,e.size*0.6,0,0,Math.PI*2); ctx.fillStyle='rgba(0,0,0,0.45)'; ctx.fill(); ctx.beginPath(); ctx.fillStyle = e.team===0? '#ffd86b':'#ff7a6a'; ctx.arc(e.x,e.y,e.size,0,Math.PI*2); ctx.fill(); } }); ctx.fillStyle='rgba(255,255,255,0.02)'; ctx.fillRect(0,0,arena.width,40); ctx.fillStyle='#ffd86b'; ctx.font='16px sans-serif'; ctx.fillText('Clash-Lite — Singlefile',14,26); ctx.fillStyle='rgba(255,255,255,0.6)'; ctx.font='14px sans-serif'; ctx.fillText('Towers P:' + towers.filter(t=>t.team===0).length + ' E:' + towers.filter(t=>t.team===1).length, arena.width-220,26); }

function loop(ts){ const dt = Math.min(0.05,(ts-lastTime)/1000); lastTime=ts; if(!gameRunning) requestAnimationFrame(loop); playerElixir = Math.min(MAX_ELIXIR, playerElixir + ELIXIR_RATE*dt); aiBehavior(dt); updateEntities(dt); draw(); renderHand(); elixirText.innerText = Math.floor(playerElixir) + '/' + MAX_ELIXIR; elixirFill.style.width = Math.min(100, (playerElixir/MAX_ELIXIR)*100) + '%'; if(gameRunning) requestAnimationFrame(loop); }

function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); ctx.fill(); }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

// init
deck = CARD_DATA.slice(0,8).map(c=>c.id);
playerDeck = deck.slice(); enemyDeck = CARD_DATA.map(c=>c.id).slice();
for(let i=0;i<4;i++) drawCard();
renderDeck(); draw(); gameRunning=true; lastTime = performance.now(); requestAnimationFrame(loop);
</script>
</body>
</html>
